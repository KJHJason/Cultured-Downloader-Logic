package cdlogic

import (
	"fmt"
	"net/http"
	"os"
	"path/filepath"

	"github.com/KJHJason/Cultured-Downloader-Logic/api"
	cdlerrors "github.com/KJHJason/Cultured-Downloader-Logic/errors"
	"github.com/KJHJason/Cultured-Downloader-Logic/parsers"
)

// parse the Netscape cookie file generated by extensions like Get cookies.txt LOCALLY
func ParseNetscapeCookieFile(filePath, website, userAgent string) ([]*http.Cookie, error) {
	if filePath == "" {
		return nil, fmt.Errorf(
			"error %d: file path cannot be empty for website %q",
			cdlerrors.INPUT_ERROR,
			website,
		)
	}

	sessionCookieInfo := parsers.GetSessionCookieInfo(website)
	sessionCookieName := sessionCookieInfo.Name
	sessionCookieSameSite := sessionCookieInfo.SameSite

	f, err := os.Open(filePath)
	if err != nil {
		return nil, fmt.Errorf(
			"error %d: opening cookie file at %s, more info => %w",
			cdlerrors.OS_ERROR,
			filePath,
			err,
		)
	}
	defer f.Close()

	var cookies []*http.Cookie
	cookieArgs := parsers.NewCookieInfoArgs(sessionCookieName, sessionCookieSameSite)
	if ext := filepath.Ext(filePath); ext == ".txt" {
		cookies, err = parsers.ParseTxtCookieFile(f, filePath, cookieArgs)
	} else if ext == ".json" {
		cookies, err = parsers.ParseJsonCookieFile(f, filePath, cookieArgs)
	} else {
		err = fmt.Errorf(
			"error %d: invalid cookie file extension, %q, at %s...\nOnly .txt and .json files are supported",
			cdlerrors.INPUT_ERROR,
			ext,
			filePath,
		)
	}

	if err != nil {
		return nil, err
	}

	if len(cookies) == 0 {
		return nil, fmt.Errorf(
			"error %d: no session cookie found in cookie file at %s for website %q",
			cdlerrors.INPUT_ERROR,
			filePath,
			website,
		)
	}

	if err := api.VerifyCookies(website, userAgent, cookies); err != nil {
		return nil, err
	}
	return cookies, nil
}
